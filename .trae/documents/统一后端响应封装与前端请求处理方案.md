## 目标
- 后端统一返回 `{ code, msg, data }` 封装
- 错误码约定：`code=0` 成功、`code=401` 未登录、`code=500` 服务异常
- 前端统一封装请求：成功直接取 `data`，失败弹出 `msg` 提示并抛出错误

## 后端改造
- 新增统一响应类型与输出函数
  - 定义 `type Resp struct { Code int; Msg string; Data any }`
  - 提供 `writeOK(w, data)` 返回 `{code:0,msg:"成功",data}`，`writeErr(w, code, msg)` 返回 `{code,msg,data:null}`
- 统一错误处理中间件
  - `recover` 捕获 panic → `writeErr(500, "服务异常")`
  - 授权中间件 `withAuth` 检测失败 → `writeErr(401, "暂未登录")`
- 所有业务接口改造
  - 成功场景：原有 payload 放入 `data` 字段
  - 失败场景：按场景返回 `code` 与 `msg`（如未找到返回 `code=404`+`msg="not_found"` 或按你意愿统一到 `500`）
- HTTP 状态码策略
  - 保留语义化 HTTP 状态（如 401/404/500），同时在响应体携带统一 `{code,msg}`，便于前端一致处理
  - 如你希望所有响应都用 `200`，也可切换为仅体内 `code` 判定（可配置）

## 前端改造
- 请求工具统一封装
  - `request.ts` 改为解析 `{code,msg,data}`：
    - `code===0` → 返回 `data`
    - 其他 `code` → 弹出 `msg`，抛出错误
  - 401 专属处理：
    - 遇到 `code===401`：弹窗“暂未登录”，触发登录流程（保留读响应头 token 的现有逻辑），登录后可选择自动重试
- 保持现有登录读取响应头
  - 登录接口仍从响应头读 `Authorization`/`X-Token`，存入 `auth-token`
- 业务调用改法
  - 所有 `get/post`、`store` 方法不再直接读裸 payload，而是取返回的 `data`
  - 成功不提示，错误统一弹出 `msg`

## 影响范围与改造点
- 后端需更新：`/api/records/*`、`/api/statistics/*`、`/api/index/list`、`/api/ranking/list`、`/api/auth/weapp`
- 前端需更新：`src/utils/request.ts`、使用这些接口的 `store/simple.ts` 与页面（index/statistics/ranking/profile）

## 验证流程
1. 未登录调用受保护接口 → 返回 `{code:401,msg:"暂未登录"}`，前端弹窗提示
2. 登录成功（响应头下发 token）后，调用接口返回 `{code:0,data:...}`，页面正常展示
3. 人为触发异常（如数据库错误）→ 返回 `{code:500,msg:"服务异常"}`，前端弹出错误

## 交付安排
- 先完成后端统一封装与中间件
- 再改造前端请求工具与受影响的 `store`/页面
- 完成端到端联调与用例验证（登录、记录列表/详情、统计、排行榜）

确认后我将开始后端和前端的同步改造，并给出具体代码更新。