**目标**
- 统一在一处处理 token 注入与 401 错误，避免各处手写。
- 为接口提供灵活标记：默认需鉴权，明确标记为公开接口则不带 token。
- 响应 401/403 时统一提示并跳转登录。

**设计**
- 在 `src/utils/request.ts` 提供统一封装：`request<T>(options)` + `get/post/put/del`。
- 扩展 `RequestOptions`：`requireAuth?: boolean`、`rawResponse?: boolean`、`timeout?: number`、`headers?: Record<string,string>`。
- 提供 `setBaseURL(url)`、`setAuthConfig({ publicPaths: RegExp[] })` 维护公开路径规则（默认空）。
- 令牌获取：统一使用 `Taro.getStorageSync('auth-token')`；当 `requireAuth!==false` 且无 token → 统一阻断并弹窗提醒。
- 令牌注入：仅在需要鉴权的接口为请求头添加 `Authorization: Bearer <token>`。
- 统一错误处理：
  - 非 2xx → `showToast('请求失败')`；
  - 401/403 → `showToast('请先登录')`，并导航 `Taro.switchTab({ url: '/pages/profile/index' })`。
- 可选 Taro 拦截器：`registerInterceptors()` 做请求/响应日志与全局兜底（不改变核心逻辑）。

**实现要点**
- `isPublic(url)`：匹配 `publicPaths` 列表或根据 `options.requireAuth===false` 覆盖，公开接口不带 token。
- 查询串拼接与绝对/相对 URL 解析，保持 H5/WeApp 一致。
- 返回结构：默认返回 `res.data`，当 `rawResponse===true` 返回完整 `Taro.request` 响应。

**使用示例**
- 设置：
  - `setBaseURL('http://10.30.1.53:8081')`
  - `setAuthConfig({ publicPaths: [/^\/api\/auth\//] })`
- 登录接口（公开）：`post('/api/auth/weapp', payload, { requireAuth: false })`
- 排行榜接口（默认需鉴权）：`get('/api/ranking/list', { period: 'day' })`

**迁移步骤**
1. 在 `src/utils/request.ts` 增加上述能力（不改调用处逻辑）。
2. 在应用启动（`src/app.ts`）设置 `setBaseURL` 与 `setAuthConfig`。
3. 将各接口调用改为 `get/post/...` 并删除手写 token 逻辑；登录接口传 `requireAuth:false` 或匹配为公开路径。
4. 验证 401 行为：无 token 调用受保护接口时提示并跳转。

**验证**
- H5 与小程序分别调用公开与受保护接口，检查是否自动注入 token。
- 清除 `auth-token` 后调用受保护接口，验证统一提示与跳转。
- 登录后重试，验证通过。

请确认方案，我将按此在 `src/utils/request.ts` 扩展能力，并在 `src/app.ts` 写入初始化配置，同时将现有页面里的手工 `Taro.getStorageSync('auth-token')` 移除改用统一封装。