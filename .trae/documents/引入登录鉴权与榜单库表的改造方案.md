## 需求概述
- 所有接口需登录后才能调用，未登录弹窗提示并可点击触发登录
- 前端存储后端返回的 token，后端可配置 token 有效期
- 首页进入时不请求列表接口（延迟加载）
- 个人记录列表仅查询当前用户，依据 token 识别用户，无需前端传 `userId`
- 排行榜独立库表：记录用户ID、名称、日期、次数

## 后端改造
### 鉴权模型
- 采用不依赖第三方库的“不透明令牌”方案：生成随机 `token`，持久化到 `sessions` 表并设置过期时间。
- 通过 `Authorization: Bearer <token>` 识别用户，所有受保护接口读取用户上下文。

### 数据库表
- `sessions`：`id`（PK）、`userId`、`token`（唯一索引）、`expiresAt`（BIGINT 毫秒）
- `leaderboard`：`id`（PK）、`userId`、`userName`、`day`（YYYY-MM-DD 字符串或 DATE）、`count`（INT），唯一键 `(userId, day)` 以便 UPSERT。
- 兼容当前数据库实现（SQLite 或 MySQL）：分别提供对应建表 SQL 与 UPSERT 写法。

### 配置项
- `TOKEN_TTL_SECONDS`（默认 7天）：控制 token 有效期
- `PORT`、`WECHAT_APPID`、`WECHAT_SECRET`：保持现有用法

### 接口与中间件
- 中间件 `AuthRequired`：
  - 读取 `Authorization` 头，解析 Bearer token
  - 查询 `sessions` 表，校验存在且未过期
  - 将 `userId` 注入请求上下文，后续处理直接使用
- 放行接口：`/api/health/ping`、`/api/auth/weapp`（登录换 token）
- 受保护接口：`/api/records/*`、`/api/statistics/*`、`/api/index/list`、`/api/ranking/list`

### 登录流程
- `POST /api/auth/weapp`：
  - 使用 `jscode2session` 拿到 `openid`（无配置则走 mock）
  - 查/创用户（更新昵称与头像）
  - 生成 `token`，写入 `sessions` 表，设置 `expiresAt`（`now + TOKEN_TTL_SECONDS*1000`）
  - 返回 `{ user, token, expiresAt }`
- 可选：`POST /api/auth/refresh`（如需续期）

### 记录与排行榜写入
- 记录创建 `POST /api/records/create`：
  - 从上下文 `userId` 写入，无需前端传 `userId`
  - 写记录成功后，对 `leaderboard` 做每日 UPSERT：同一 `userId + day` 的 `count += 1`
- 排行榜查询 `GET /api/ranking/list?period=day|week|month|total`：
  - day：取当天 `leaderboard.day == today` 排序
  - week/month：对区间内按用户 `SUM(count)` 排序
  - total：对全量 `SUM(count)` 排序

## 前端改造
### 请求与存储
- `src/utils/request.ts` 已自动附带 `Authorization`，前端在登录后将 `token` 存入 `auth-token`（已支持）
- 新增统一鉴权助手：`ensureAuth()`
  - 检查 `auth-token` 是否存在，否则弹窗提示登录
  - 用户确认后触发 `Taro.login` + `POST /api/auth/weapp`，保存 `{ token, user }` 至本地
  - 对 401 重试场景：拦截失败后弹窗并走 `ensureAuth()`

### 页面与流程
- 首页（`src/pages/index/index.vue`）：
  - 取消 `onMounted` 立即 `store.init()` 的列表请求；仅保留计时与完成动作
  - 在保存记录 `saveRecord` 前调用 `ensureAuth()`；保存成功后本地备份
- 个人页（`src/pages/profile/index.vue`）：
  - 登录按钮走 `ensureAuth()`，保存后端返回的 `token` 与 `user`（头像、昵称）
- 列表与统计（`src/store/simple.ts`）：
  - `loadRecords` 移除 `userId` 参数，后端依据 token 识别用户
  - 遇到 401 时走 `ensureAuth()` 再重试
- 排行榜（`src/pages/ranking/index.vue`）：
  - 由后端 `leaderboard` 表返回数据；前端仅展示

## 兼容与迁移
- 保留旧本地存储作为离线备份；登录后优先使用远端数据
- 后端已存在的 `records` 数据按需批量初始化 `leaderboard`（提供一次性脚本或启动时迁移）

## 安全与体验
- Token 仅存储于小程序本地（`Taro.setStorageSync('auth-token', token)`），不在日志中输出
- 后端校验所有受保护接口，无 token 返回 401
- 提供统一弹窗与登录流程，避免多处重复逻辑

## 交付项
- 后端：鉴权中间件、`sessions`/`leaderboard` 表、登录换 token、受保护接口改造、排行榜查询改造
- 前端：`ensureAuth()` 助手、登录弹窗与触发、首页延迟加载、记录/统计/排行榜API鉴权重试

## 实施步骤
1. 后端创建 `sessions` 与 `leaderboard` 表（兼容 SQLite/MySQL），实现鉴权中间件
2. 改造 `/api/auth/weapp` 返回 `{ token, expiresAt }`
3. 调整受保护接口使用上下文 `userId`，移除对前端 `userId` 依赖
4. 记录创建时写入 `leaderboard` 的每日计数
5. 前端新增 `ensureAuth()`，在保存/列表/统计/排行榜前调用；处理 401 弹窗与重试
6. 首页移除首屏列表请求（延迟加载）
7. 压测与联调，确认全链路登录与鉴权生效

如确认该方案，我将开始实现后端鉴权与表结构，以及前端鉴权助手与页面改造。